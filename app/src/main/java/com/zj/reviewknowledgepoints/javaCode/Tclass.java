package com.zj.reviewknowledgepoints.javaCode;

/**
 * Created by zj on 2019-02-13 15:00.
 * 泛型的作用
 * https://blog.csdn.net/s10461/article/details/53941091
 */
public class Tclass {

    /**
     *  泛型，就是“参数化类型”，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成了参数形式，然后在使用时传入具体的类型
     *  本质：为了参数化类型（在不创建新的类型情况下，通过泛型指定不同类型来控制形参具体限制类型），也就是说在泛型使用过程中，操作的数据类型被指定为一个参数
     *          这种参数类型可以在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法
     *
     *  特性： 只在编译阶段有效 （泛型类型在逻辑上看成是多个不同的类型，实际上都是相同的基本类型）
     *
     *      1.泛型类
     *          基本写法： class 类名 <泛型标识：可以随便写任何标识号，标识指定的泛型的类型> {
     *
     *                  private 泛型标识(代表成员变量类型) key;
     *
     *          }
     *
     *        注意： 定义的泛型类，不一定要传入泛型类型实参，如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任意的类型；
     *
     *     2.泛型接口：
     *          与泛型类定义及使用基本相同
     *          在实现类实现泛型接口时，如已将泛型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型。
     *
     *     3. 泛型通配符：
     *           通常使用？代替具体的类型实参，*** ？是类型实参，不是类型形参**** 可以把？看成所有类型的父类，是一种真实的类型
     *           1.可以解决当具体类型不确定 2.当操作类型时，不需要使用类型的具体功能，只使用object类的功能    可以用？来表示未知类型
     *
     *     4. 泛型方法 ***
     *          泛型类，是在实例化类的时候指明泛型的具体类型。泛型方法，是在调用方法的时候指明泛型的具体类型
     *
     *         ============================================================================
     *          基本介绍：例子
     *              public <T> T genericMethod(Class<T> tClass)throws InstantiationException ,
     *                          IllegalAccessException{
     *                              T instance = tClass.newInstance();
     *                              return instance;
     *              }
     *
     *              说明： 1.public与返回值中间的<T> 非常重要，可以理解为声明次方法为泛型方法
     *                    2.只有声明了<T>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法
     *                    3.<T>表明了该方法将使用泛型类型T ，此时才可以在方法中使用泛型类型T
     *                    4.与泛型类的定义一样，此处的T可以随便写为任何标识，常见的如T、E、K、V等形式的参数常用于表示泛型
     *
     *         ============================================================================
     *         基本用法：
     *           静态方法与泛型： 有一种情况需要注意下，就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上；
     *              例如： 如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法
     *
     *                 public class StaticGenerator {
     *
     *                     //如果类中定义了使用泛型的静态方法，需要添加额外的泛型声明(将这个方法定义成泛型方法)
     *                     //即使静态方法要使用泛型类中已经声明过的泛型也不可以。
     *
     *                     public static <T> void show(T t){.....}
     *                 }
     *
     *     总结：
     *          泛型方法能使方法独立于类而产生变化，无论何时，如果能做到，就该尽量的使用泛型方法，也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。
     *          另外对于一个static的方法，无法访问泛型类型的参数，所以如果static方法要使用泛型能力，就必须使其成为泛型方法
     *
     *
     *    6. 泛型上下边界
     *
     *    7. 泛型数组
     *          在java中是不能创建一个确切的泛型类型的数组，而使用通配符是可以的
     *          List<String>[] ls = new ArrayList<String>[10]  => 错误
     *          List<？>[] ls = new ArrayList<？>[10]  => 正确
     *
     *
     *
     *
     *
     *
     */
}
